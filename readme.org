* What's the deal?
This is a pretty simple implementation of 'FizzBuzz' in Linux x64 assembly. It contains no jump instructions (not in the
binary, anyway) and implements all logic via lookup tables and an ingenious little algorithm borrowed from
http://philcrissman.net/posts/eulers-fizzbuzz/, which immediately captured my attention the moment I heard of it. It's
such an elegant idea!

There are two reasons I decided to implement this in assembly:

1. I have very little x64 assembly experience, so I wanted to write more small but non-trivial (well, /less/ trivial)
   programs to experiment with style, continue to familiarize myself with the Intel developer's guide, and the NASM
   documentation.

   You may notice, for example, that I've adopted a sort of "Hungarianesque" notation for my labels --
   the result of which is kind of ugly and uncoordinated. That's the sort of kink I'd like to work on or out of my
   workflow before ever moving onto bigger things.

   Also overused is the ~align~ directives in the ~.data~ ~section~. Those are only there because I was curious how one
   might align to a boundary in NASM.
2. Attempting to implement the conditional logic-less algorithm in a language like C or Python or Ada or Bash or what
   have you strikes me as cheating. The whole point of this is to avoid branching! Even C doesn't give us enough
   control. Too many opportunities for glibc or the CRT0 to get statically linked and introduce unwanted instructions
   into our otherwise pure binary.

   Furthermore, standard C doesn't really have any good code-repeat macros, and ~for~​/​~while~ loops are unquestionably
   branches. Infinite goto loops are fine, but I wanted the program to halt on its own so as not to fill up my eshell
   buffer too quickly and hang my editor. (That one's a cop-out but I'm sticking to it.)
* Building
Type ~make~, ~make all~ or ~make branchless-fizzbuzz~ in the top (well, only) folder of the repo to build the
executable, run it with ~./branchless-fizzbuzz~. Requires NASM, ld and cpp.

To remove all build products, type ~make clean~.
* Potential Further Improvements
1. Settle on and standardize a saner name format for labels.
2. Remove various bits of redundancy.
3. Clean up makefile. It was a hack job just to get the thing to build, and it's not up my personal standards.
4. Further extensibility to other prime number-word associations. (Compiler, anyone?)
* Other Notes
Yes, I know that under the ~syscall~ API there are undoubtedly hundreds of thousands of branches. How else do you expect
me to do output. (Return values maybe? IDK how you'd do strings.)

Moreover, if you're running an modern Intel x64 computer -- heck, if you've got a modern Intel x64 machine /plugged in/
-- you've already got a MINIX 3 install running in your chipset, which is executing plenty of branches per second
without your input or consent. AMD is similar with their ARM-based PSP.

Modern computers are abominations of science. Let me live in a little space of delusion for a while, where I can pretend
it's the 70s, that I'm writing single-threaded 8086 machine code and microprocessors are still /real./
